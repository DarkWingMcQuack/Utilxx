# Utilxx
[![License: LGPL v3](https://img.shields.io/badge/License-LGPL%20v3-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0)

Utlixx is a header only lib, which contains different types and functions I am using across multiple projects.
Utilxx is a C++17 libary and can therefor only be used with compilers supporting C++17.

A lot of types are move only to avoid copying, and most types support a monad-like interface with the functions
`flatMap` and `map`.

### Opt
`Opt` is an optional type which is based on `std::optional` but with an monad-like interface through
`flatMap` and `map`. An optional type adds another instance to the type it wraps up, the std::nullopt instance, which represents that no value is currently available. This is pretty nice for example for optional function objects, or as a return type of functions which can fail.
For example:
```C++
auto div(int first, int second) -> Opt<Int>
{
    if(second == 0){
        return std::nullopt;
    }
    return first / second;
}
```
Here the function would fail if `second` is `0`, which can be nicely repressented with the return type `Opt<int>`.

#### flatMap and map

`flatMap` of an `Opt<T>` takes a function expecting a `T` and returning a result `U` wrapped in an `Opt<U>.`
Calling `flatMap` with such an function as parameter results in an `Opt<U>` which was produced if the current
`Opt<T>` was holding an `T`, which is then extracted and passed to the function.

`map` of an `Opt<T>` takes a function expecting a `T` and returning an result `U` which is not `void`.
When calling `map` with such a function as argument results in an`Opt<U>` which was generated by passing the wrapped up `T` into the given function and `std::nullopt` else.

With those two function chaining calls to different functions is super easy.
Imagine functions with signatures like:
```C++
auto first() -> Opt<int>;
auto second(int) -> Opt<std::string>;
auto third(std::string) -> Opt<double>;
auto fourth(double) -> int;
```
If you want to call the `second` function on the result of the `first` function and then the `third` function with that result, you could do this with if else:
```C++
auto compute() -> Opt<int>
{
    auto first_opt = first();
    if(first_opt){
        auto second_opt = second(first_opt.getValue());
        if(second_opt){
            auto third_opt = third(second_opt.getValue());
            if(third_opt){
                return fourth(third_opt.get());
            }
        }
    }
    
    return std::nullopt;
}
```
This works, but it is incredibly easier using `flatMap` and `map`, which would look like this:
```C++
auto compute() -> Opt<int>
{
    return first()
    .flatMap([](auto&& first_res){
        return second(first_res);
    })
    .flatMap([](auto&& second_res){
        return third(second_res);
    })
    .map([](auto&& third_res){
        return fourth(third_res);
    });
}
```
This does exactly the same as the one above, but you dont have any complex `if-else` constructs.

#### onValue
Another function an `Opt<T>` provides is `onValue`.
A call to `onValue` expects a function taking an `T` and returning `void`.
One can think of `onValue` as some kind of `if` construct.
For example the following:
```C++
auto foo() -> Opt<std::string>;

auto bar() -> void
{
    auto opt = foo();
    if(opt){
        ... do something ...
    }
}
```
could also be written as:
```C++
auto foo() -> Opt<std::string>;

auto bar() -> void
{
    auto opt = foo();
    
    opt.onValue([](auto&& str){
        ... do something ...
    });    
}
```
or even as:
```C++
auto foo() -> Opt<std::string>;

auto bar() -> void
{
    auto opt = foo()
        .onValue([](auto&& str){
            ... do something ...
        });    
}
```
because `onValue` returns the object calling it after executing the passed function.

#### onError
`onError` is the equivalent of `onValue`, but the passed function does expect any parameters and musst return `void`.
The passed function will be executed if the `Opt` does not hold a value.
With `onValue` and `onError` if else like structures can be simulated.
For example this:
```C++
auto foo() -> Opt<std::string>;

auto bar() -> void
{
    auto opt = foo();
    if(opt){
        ... do something ...
    }else{
        ... do something else ...
    }
}
```
could also be written as:
```C++
auto foo() -> Opt<std::string>;

auto bar() -> void
{
    auto opt = foo()
        .onValue([](auto&& str){
            ... do something ...
        })
        .onError([]{
        ... do something else ...
        });
}
```

#### finally
The `finally` member function of `Opt` expects a function without any parameters which returns `void`, just like `onError`.
The difference to `onError` is, that the passed function will be executed no matter what the `Opt`s current state is.
Using `finally`, `onError` and `onValue`, a `if-else-finally` like controlflow can be build.
Assuming C++ would have a `if-else-finally` like controlflow structure, this:
```C++
auto foo() -> Opt<std::string>;

auto bar() -> void
{
    auto opt = foo();
    if(opt){
        ... do something ...
    }else{
        ... do something else ...
    }finally{
        ... do this finally ...
    }
}
```
could also be written as:
```C++
auto foo() -> Opt<std::string>;

auto bar() -> void
{
    auto opt = foo()
        .onValue([](auto&& str){
            ... do something ...
        })
        .onError([]{
        ... do something else ...
        })
        .finally([]{
        ... do this finally ...
        });
}
```

#### flatten
A call to `flatten` flattens out nested `Opt<Opt<...<T>...>>` to just `Opt<T>`

#### combine
When an object of type `Opt<T>` calls `combine` with an `Opt<U>` as parameter,
it returns an `Opt<std::pair<T,U>>` which holds the two values wrapped in the `Opts`, or
`std::nullopt` if one of them or both hold an `std::nullopt`.
This is handy when two values are needed to continue a computation.
For example:
```C++
auto foo() -> Opt<std::string>;
auto bar() -> Opt<int>;
auto baz(std::string, int) -> double;
auto compute() -> Opt<double>
{
    auto first = foo();
    auto second = bar();
    if(first && second){
        return baz(first.getValue(), second.getValue());
    }
    return std::nullopt;
}
```
can be implemented much easier with `combine`:
```C++
auto foo() -> Opt<std::string>;
auto bar() -> Opt<int>;
auto baz(std::string, int) -> double;
auto compute() -> Opt<double>
{
    return foo()
    .combine(bar())
    .map([](auto&& pair){
        auto&&[first, second] = pair;
        return baz(first, second);
    });
}
```
`combine` also exists as free function expecting two `Opt`s.

### Result
Sometime `Opt` is not enought as a function return type. Whenever the caller of a function wants to know what exactly went wrong when calling the function instead of just the fact that something went wrong.
Here `Result` can help. A function returning a `Result<T, E>` normaly returns a value of type `T`, but in the case of an error it returns an error of type `E`. 
For example:
```C++
auto div(int first, int second, int third) -> Result<int, std::string>
{
    if(second == 0){
        return "second value was 0"s;
    }
    
    if(third == 0){
        return "third value was 0"s;
    }
    
    return (first / second) / third;
}
```
With a function like this, the caller can check with `hasValue` or `hasError` if a value was produced and continue with function like `onValue`, `flatMap` and so on descriped earlier in the `Opt` section with the value. When no value was produced, the caller can use `mapError`, `flatMapError`, `onError` or `getError` to continue with the given error.
